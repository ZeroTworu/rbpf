### Rust eBPF Firewall (POC)

#### Описание:

Демонстрация возможности написания eBPF Firewall на Rust, оно же Proof Of Concept.

* Поддерживает `IP` `v4`/`v6`, `TCP`/`UDP`.
* Для обработки исходящих соединений используется `Classifiers`. 
* Для обработки входящих - `eXpress Data Path`.
* Логирование целиком в `userspace`.
* HTTP REST API для управления фаерволом.
* Web UI.
* Поддержка архитектур: `x86_64`, `armv7`, `aarch64`.

#### Структура проекта:
* `rbpf-common` - Общие структуры, которыми компоненты обмениваются через `BPF_MAPS` user space <-> eBPF (kernel space) или control Unix Socket. 


* `rbpf-ebpf` - eBPF модуль загружаемый в ядро.


* `rbpf-http` - HTTP REST API сервер, так как `rbpf-loader` запускается из-под `root` что бы иметь возможность загрузить eBPF модуль, то в самом
`rbpf-loader` мы не можем держать HTTP REST API сервер. Запускать HTTP сервер от `root` - крайне плохая затея с точки зрения безопасности.


* `rbpf-loader`- Модуль загружающий `rbpf-ebpf`, и обеспечивающий связь между user space и eBPF (kernel space). Может создавать Unix Socket для приёма команд.

* `rbpf-ui` - WebUI (Single Page Application написанное на Vue.js v3). Служит для вывода информации и управления eBPF модулем. 

#### ![logs](assets/logs_table.png)


#### ![rules_table](assets/rules_table.png)

#### Принцип работы:

##### Передача информации из ядра в браузер
* `(eBPF module in kernel`) -> `(RingBuf)` -> `(loader module in root space)` -> `(unix socket)` -> `(HTTP module in user space)` -> `(web socket)` -> `(browser)`

##### Передача информации из браузера в ядро
* `(browser)` -> `(HTTP request)` -> `(HTTP module in user space)` -> `(unix socket)` -> `(loader module in root space)` -> `(BPF HASH MAP)` -> `(eBPF module in kernel`)


#### Быстрая сборка:
* `./build.sh --build-bin` - Сборка Rust приложения (x86_64).
* `./build.sh --build-bin-armv7` - Сборка Rust приложения (armv7).
* `./build.sh --build-bin-aarch64` - Сборка Rust приложения (aarch64).
  * Для `Debian 12.10.0` под `armhf` и `aarch64` (видимо проблема в debian, а не архитектурах) пришлось выполнить `tc qdisc add dev <IFACE> clsact` (для OUTPUT listener) и `ip link set dev <IFACE> xdp off` (для INPUT listener) иначе листенеры не хотели цепляться к сетевым интерфейсам.
  * Добавил ключи `--fi` и `--fo` для автоматического применения этих комманд при запуске `rbpf_loader` для `input` и `output` интерфейсов соответственно.
------
* `./build.sh --build-bin-zip` - Сборка и упаковка Rust приложения (x86_64).
* `./build.sh --build-bin-zip-armv7` - Сборка и упаковка Rust приложения (armv7).
* `./build.sh --build-bin-zip-aarch64` - Сборка и упаковка Rust приложения (aarch64).

------
* `./build.sh --build-vue` - Сборка WebUI приложения.
* `./build.sh --build-vue-zip` - Сборка и упаковка WebUI приложения.


#### Настройка рабочей среды для разработки:
1. Установить [Rust](https://www.rust-lang.org/learn/get-started)
2. `rustup default stable`
3. `rustup toolchain add nightly`
4. `rustup component add rust-src --toolchain nightly`
5. `cargo install cargo-generate`
6. `cargo install bpf-linker`
7. `cargo install bindgen-cli`

### Xtask
После подготовки рабочей среды вам доступны `cargo xtask`, краткое описание.

* `cargo xtask build-bin <ARCH>` Создание бинарных файлов, доступные архитектуры:
  * `x86_64`
  * `armv7`
  * `aarch64`
  
* `cargo xtask build-bin-zip <ARCH>` Аналогично предыдущей, только с упаковкой в архиа.

* `cargo xtask build-vue` Генерация WebUI.
* `cargo xtask build-vue-zip` Генерация WebUI и упаковка в архив.
* `cargo xtask prepare` Подготовка дополнительных файлов для упаковки в пакеты.
* `cargo xtask build-pkg <PKG>` Создание установочного пакета, в качестве `<PKG>` доступны: 
  * `zst`
  * `deb`
  * `rpm`


#### Описание настроек:

##### Настройки `rbpf-loader` находятся в `contrib/settings/main.yaml`.
* При запуске можно указать ключ `-c <settings path>`, по умолчанию предполагается, что настройки лежат рядом с бинарником.

`interfaces` - Сетевые интерфейсы с которыми работаем.

* `input` - Список интерфейсов на которых обрабатываем входящий траффик.

* `output` - Список интерфейсов на которых обрабатываем исходящий траффик.

`control` - Блок настроек внешнего управления..

* `on` - Включает / выключает создание управляющего Unix Socket.


* `control_socket_path` - Полный путь в ФС до сокет-файла.


* `control_socket_owner` - Основная идея в том, что HTTP REST API сервер, будет работать под пользователем с пониженными правами, 
поэтому у сокет-файла мы должны сменить владельца, что бы HTTP модуль мог с ним взаимодействовать.


* `control_socket_chmod` - Права доступа к управляющему сокет-файлу.


`logs` - Блок настрое сокет-файла логов. Если он включен, то в него идёт стримминг всех событий из eBPF.

* `on` - Включает / выключает создание стримингово Unix Socket.


* `logs_socket_path` - Полный путь в ФС до сокет-файла логов.


* `logs_socket_owner` - То же самое что и у `control_` только для логов.


* `logs_socket_chmod` - То же самое что и у `control_` только для логов.

`db` - Блок настроек для работы с базой данных `SQLite`. Используется для хранения правил созданных пользователем через WebUI.


* `on` - Включает / выключает работу с БД. При включении, при запуске надо указывать ключ `-m <migrations path>` - путь до директории с миграциями. По умолчанию он `./migrations/`.

  * Если работа с БД включена, но файл ещё создан или создан или не применены все миграции - приложение будет работать не стабильно, скорее всего будет просто panic при попытки чтения / записи из / в БД.


* `path` - Путь до файла базы данных. Относительный или обсалютный.

`elk:` - Блок настроек отвечающий за работу с ELK (Elasticsearch, Logstash, Kibana)
* `on` - Включает / выключает работу с ELK.
* `elastic_host` - Адрес хоста Elasticsearch куда слать логи.


##### Настройки `rbpf-http` находятся в `contrib/settings/http.yaml`
* При запуске можно указать ключ `-c <settings path>`, по умолчанию предполагается, что настройки лежат рядом с бинарником.

`http_api` - Блок настроек HTTP. Единственный блок в файле.

* `addr` - Адрес на который биндится.


* `port` - Порт на который биндится.


* `control_socket_path` - Полный путь до control Unix Socket создаваемый `rbpf-loader`.


* `logs_socket_path` - Путь до сокет-файла логов, если мы хотим принимать их.


* `listen_logs` - Включает WebSocket server который принимает логи и пересылает их на фронтенд.


* `vue_app_on` - Включает раздачу статики, лежащей по `vue_dist_path` - Предполагается, что там лежит собранный WebUI.


* `vue_dist_path` - Путь до WebUI приложения.


**ВАЖНО:** хоть `rbpf_http` принимает все логи, на фронтенд ухедят только те, которые появились и-за срабатывания какого либо правила.
Нужно это потому что при `RUST_LOG=debug` создаётся такое кол-во логов, что WS соединение между браузером и `rbpf_http` обрывается через несколько секунд.  

`swagger_ui` - Отвечает за включение SwaggerUI.

`cors` - Позволяет задать список разрешённых origin'ов (источников) для CORS-запросов к HTTP API.

#### Обработка траффика:
Правила обработки траффика находятся в `contrib/rules/`
* При запуске `rbpf-loader` можно указать ключ `-r <rules path>`, по умолчанию предполагается, что правила лежат в `./rules/` рядом с бинарником.

`name:` - Имя правила, ни на что не влияет, просто выводится в лог.

`order` - Порядок размещения в `HashMap` правила обработки. Обработка траффика идёт от меньшего к большему, т.е. правило с `order: 0` будет вверху цепочки, а `order: 511` - в самом низу. Максимальное кол-во правил - `512` в силу ограничений `eBPF`.
Не обязательно соблюдать строгое следование `1,2,3,4...` система сама выставит их в `HashMap` даже если будет `0, 20, 41..`.

`iface` - Имя сетевого интерфейса, к которому применяется правило, `*` - все интерфейсы. Имена интерфейсов можно получить командой `ip addr`.

`on` - Включает / выключает правило.

`tcp:` - Включает правило для TCP

`udp:`  - Включает правило для TCP
* Если оба `false` то правило не будет применятся.


`ok:` - Отдаёт в обработчик `Action::OK` и прерывает дальнейшую обработку правил. Траффик идёт дальше.

`drop:` - Отдаёт в обработчик `Action::DROP` и прерывает дальнейшую обработку правил. Траффик блокируется.
*  Если оба `false` то правило не будет применятся.


`input:` - Правило обрабатывает входящий траффик.

`output:` - Правило обрабатывает исходящий траффик. 
*  Если оба `false` то правило не будет применятся. 


`v4:` - Обрабатывать IPv4

`v6:`  - Обрабатывать IPv6
*  Если оба `false` то правило не будет применятся.


`source_addr_v4:` - Исходящий IPv4 адрес

`destination_addr_v4` - IPv4 адрес назначения.

`source_addr_v6` - Исходящий IPv6 адрес

`destination_addr_v6`- IPv6 адрес назначения.
* Все адреса можно указывать вместе с маской подсести `127.0.0.0/24`, `::1/24`.


`source_port_start` - Указание диапазона портов, порт источника с которого начинается диапазон.

`source_port_end` - Указание диапазона портов, порт источника которым заканчивается диапазон.
* Если необходимо указать конкретный порт - оба значения выставляются в этот порт.


`destination_port_start` - Указание диапазона портов, порт назначения которым заканчивается диапазон.


`destination_port_end` - Указание диапазона портов, порт назначения которым заканчивается диапазон.
* Если необходимо указать конкретный порт - оба значения выставляются в этот порт.
