### Rust eBPF Firewall (POC)

#### Описание:

Демонстрация возможности написания eBPF Firewall на Rust, оно же Proof Of Concept.

* Поддерживает `IP` `v4`/`v6`, `TCP`/`UDP`.
* Для обработки исходящих соединений используется `Classifiers`. 
* Для обработки входящих - `eXpress Data Path`.
* Логирование целиком в `userspace`.
* HTTP REST API для управления фаерволом.
* Web UI

#### Структура проекта:
* `rbpf-common` - Общие структуры, которыми компоненты обмениваются через `BPF_MAPS` user space <-> eBPF (kernel space) или control Unix Socket. 


* `rbpf-ebpf` - eBPF модуль загружаемый в ядро.


* `rbpf-http` - HTTP REST API сервер, так как `rbpf-loader` запускается из-под `root` что бы иметь возможность загрузить eBPF модуль, то в самом
`rbpf-loader` мы не можем держать HTTP REST API сервер. Запускать HTTP сервер от `root` - крайне плохая затея с точки зрения безопасности.


* `rbpf-loader`- Модуль загружающий `rbpf-ebpf`, и обеспечивающий связь между user space и eBPF (kernel space). Может создавать Unix Socket для приёма команд.

* `rbpf-ui` - Single Page Application написанное на Vue.js v3. Служит для вывода информации и управления eBPF модулем. 

#### ![rbpf](assets/logs_table.png)

#### Принцип работы

##### Передача информации из ядра в браузер
* `(eBPF module in kernel`) -> `(RingBuf)` -> `(loader module in root space)` -> `(unix socket)` -> `(HTTP module in user space)` -> `(web socket)` -> `(browser)`

##### Передача информации из браузера в ядро
* `(browser)` -> `(HTTP request)` -> `(HTTP module in user space)` -> `(unix socket)` -> `(loader module in root space)` -> `(BPF HASH MAP)` -> `(eBPF module in kernel`)

#### Сборка и запуск:

1. Установить [Rust](https://www.rust-lang.org/learn/get-started)
2. `rustup default stable`
3. `rustup toolchain add nightly`
4. `rustup component add rust-src --toolchain nightly`
5. `cargo install cargo-generate`
6. `cargo install bpf-linker`
7. `cargo install bindgen-cli`
8. `make build` - Сборка проекта.
9. `make run-loader` - Запуск `rbpf-loader` и загрузка `rbpf-ebpf` в ядро, требуется `roor`. Если в `Makefile` изменить `RUST_LOG=info` на `RUST_LOG=debug` то будет показан весь перехватываемый траффик.
10. `make run-http` - Запуск `rbpf-http`, нужно запускать от пользователя, который имеет доступ к control Unix Socket. Если в `Makefile` изменить `RUST_LOG=info` на `RUST_LOG=debug` то будет показан весь перехватываемый траффик.


#### Описание настроек:

##### Настройки `rbpf-loader` находятся в `cobtrib/settings/main.yaml`.
* При запуске можно указать ключ `-c <settings path>`, по умолчанию предполагается, что настройки лежат рядом с бинарником.

`interfaces` - Сетевые интерфейсы с которыми работаем.

`input / output` соответственно отвечают за то, какой тип трафика на указанном интерфейсе обрабатываем.

`control` - Блок настроек внешнего управления..

`on` - Включает / выключает создание управляющего Unix Socket.

`control_socket_path` - Полный путь в ФС до сокет-файла.

`control_socket_owner` - Основная идея в том, что HTTP REST API сервер, будет работать под пользователем с пониженными правами, 
поэтому у сокет-файла мы должны сменить владельца, что бы HTTP модуль мог с ним взаимодействовать.

##### Настройки `rbpf-http` находятся в `cobtrib/settings/http.yaml`
* При запуске можно указать ключ `-c <settings path>`, по умолчанию предполагается, что настройки лежат рядом с бинарником.
`http_api` - Блок настроек HTTP. Единственный блок в файле.

`addr` - Адрес на который биндится.

`port` - Порт на который биндится.

`control_socket_path` - Полный путь до control Unix Socket создаваемый `rbpf-loader`.

#### Обработка траффика:
Правила обработки траффика находятся в `contrib/rules/`
* При запуске `rbpf-loader` можно указать ключ `-r <rules path>`, по умолчанию предполагается, что правила лежат в `./rules/` рядом с бинарником.

`name:` - Имя правила, ни на что не влияет, просто выводится в лог.

`iface` - Имя сетевого интерфейса, к которому применяется правило, `*` - все интерфейсы. Имена интерфейсов можно получить командой `ip addr`.

`on` - Включает / выключает правило.

`tcp:` - Включает правило для TCP

`udp:`  - Включает правило для TCP
* Если оба `false` то правило не будет применятся.


`ok:` - Отдаёт в обработчик `Action::OK` и прерывает дальнейшую обработку правил. Траффик идёт дальше.

`drop:` - Отдаёт в обработчик `Action::DROP` и прерывает дальнейшую обработку правил. Траффик блокируется.
*  Если оба `false` то правило не будет применятся.


`input:` - Правило обрабатывает входящий траффик.

`output:` - Правило обрабатывает исходящий траффик. 
*  Если оба `false` то правило не будет применятся. 


`v4:` - Обрабатывать IPv4

`v6:`  - Обрабатывать IPv6
*  Если оба `false` то правило не будет применятся.


`source_addr_v4:` - Исходящий IPv4 адрес

`destination_addr_v4` - IPv4 адрес назначения.

`source_addr_v6` - Исходящий IPv6 адрес

`destination_addr_v6`- IPv6 адрес назначения.
* Все адреса можно указывать вместе с маской подсести `127.0.0.0/24`, `::1/24`.


`source_port_start` - Указание диапазона портов, порт источника с которого начинается диапазон.

`source_port_end` - Указание диапазона портов, порт источника которым заканчивается диапазон.
* Если необходимо указать конкретный порт - оба значения выставляются в этот порт.


`destination_port_start` - Указание диапазона портов, порт назначения которым заканчивается диапазон.


`destination_port_end` - Указание диапазона портов, порт назначения которым заканчивается диапазон.
* Если необходимо указать конкретный порт - оба значения выставляются в этот порт.
